ğŸ“… Daily Progress Update â€“ 2026-01-07
Phase 4 â€“ Inter-Processor Communication

Milestone reached: MCU â†’ Linux bridge validated

Todayâ€™s focus was on completing the first inter-processor communication sanity check and documenting the learnings properly.

âœ… What was achieved

Successfully established one-way communication from MCU to Linux using the Arduino UNO Q Bridge

Validated periodic message transfer (bridge_alive counter at 1 Hz)

Confirmed:

message delivery is reliable

payload integrity is preserved

MCU remains stable during communication

This marks the first confirmed data path across the MCU â†” Linux boundary

ğŸ” Key technical learnings

The Arduino UNO Q Bridge Python API does not support Bridge.on()

Correct pattern is:

Bridge.provide() on the Linux/Python side

Bridge.notify() (or Bridge.call()) on the MCU side

Python process lifetime is critical

If the Python script exits, App Lab shuts down the entire application

A persistent event loop is mandatory, even for simple tests

Startup sequencing matters

The MCU can begin sending messages before the Python runtime is ready

Adding a deliberate startup delay avoids silent message loss

Keeping the payload minimal (single counter value) made validation unambiguous and debugging far easier

ğŸ“„ Documentation updates

PDF 4.2 â€“ Bridge Sanity Check & First Message

Marked as validated on hardware

PDF 4.2.1 â€“ Implementation Walkthrough & Key Learnings

Added full MCU and Python reference code

Captured root causes, fixes, and rationale

Highlighted this step as a major project milestone

ğŸ§­ Why this matters

This step proves that:

the bridge infrastructure works in practice

architectural separation between MCU and Linux is viable

the project can now safely progress toward transferring real CAN data

The â€œbaby stepsâ€ approach paid off by making failure modes clear and recoverable.

ğŸ”œ Next steps

Define message formats and contracts (PDF 4.3)

Prepare for sending a single fixed CAN frame across the bridge

Continue incremental validation before increasing complexity


-------------------------------------------------------------------------------------------------------------------------------------------------


ğŸ“… Project Update â€” 2026-01-05
Phase 3 â€“ MCU Software Architecture Completed & Stabilised

Todayâ€™s work focused on closing Phase 3 properly, aligning documentation with the actual integrated system, and resolving a real-world driver integration issue on the Arduino UNO Q platform.

âœ… What was achieved today
1. CAN reception fully validated on hardware

MCP2515 successfully receiving CAN frames from external CAN transmit software

Stable reception confirmed with:

correct CAN IDs and payloads

consistent timing (t_ms) aligned with transmit period

zero receive errors under nominal load

Ring buffer counters verified:

rx_count == push_ok

buf_overflow == 0

rx_error == 0

2. Driver library issue identified and resolved

Initial MCP2515 library blocked during CAN initialization on Arduino UNO Q

Hardware and SPI transport were verified independently (SPI register reads OK)

Issue isolated to library behavior on this platform

Driver replaced with Autowp MCP2515 library

New driver demonstrated:

non-blocking initialization

reliable frame reception

clean error handling

This confirmed the value of treating the driver layer as replaceable in the architecture.

3. Diagnostic output stabilised for UNO Q

Identified that UNO Q Monitor output can interleave text due to RouterBridge transport

Refactored diagnostics to:

assemble full log lines in memory

emit each message in a single print call

rate-limit frame and stats output

Result: clean, readable CAN frame logs suitable for tutorials and debugging

4. Phase 3 documentation fully restructured and finalised

Phase 3 documentation is now split into five clean, single-purpose PDFs:

PDF 3.1 â€“ MCU Responsibilities & Task Design
(architecture only, unchanged by implementation details)

PDF 3.2 â€“ MCP2515 Driver Overview
(driver role, expectations, polling choice for Phase 3)

PDF 3.3 â€“ CAN Receive Loop & Buffering
(polling loop, ring buffer, counters, decoupling)

PDF 3.4 â€“ Timing & Data Integrity
(timestamping strategy, integrity definition, validation via counters)

PDF 3.X â€“ Driver Library Change (Root Cause & Resolution)
(documents the library failure, investigation, and resolution)

All PDFs:

reference MCU.ino for implementation

intentionally avoid embedding source code

preserve architectural intent while documenting real integration learning

5. Phase 3 formally closed

Architecture validated against real hardware behavior

Documentation aligned with implementation

No open technical debt in Phase 3

ğŸ”œ Next Steps

Begin Phase 4 â€“ Inter-Processor Communication

Introduce Arduino Bridge / RPC concepts

Transition from local diagnostics to MCU â†’ Linux data transfer
